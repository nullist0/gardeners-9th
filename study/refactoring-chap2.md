# 리팩터링 원칙

## 리팩터링 정의

리팩터링은 이하의 단어로 정의한다.

> 리팩터링[명사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

> 리팩터링 [동사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

리팩터링의 경우 기본 동작을 유지해야하므로, 리팩터링을 하다가 코드가 깨져서 고생했다는 문장은 성립되지 않는다. 리팩토링과 유사한 작업으로는 성능 최적화가 있다. 전반적인 기능은 유지한채로 코드를 수정하는 것이다. 그 과정에서 콜스택이 바뀌거나 인터페이스가 바뀔때도 있다.

## 리팩토링의 장점

- 소프트웨어 설계가 좋아진다.
- 소프트웨어를 이해하기 쉬워진다.
- 버그를 쉽게 찾을 수 있다.
- 프로그래밍 속도를 높일 수 있다.

## 언제 리팩터링을 해야할까?

> 3의 법칙 (삼진 리팩터링)
>
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

### 리팩터링의 종류

저자의 경우 보기 싫은 코드를 발견하면 리팩터링을 기회가 될때 수행한다. 개발 작업과 리팩터링 작업이 일체화 되어 있는 것이다. 계획된 리팩터링이 나쁜것은 아니지만 리팩터링은 점진적으로 진행되어야 하는 작업이며, 맥락에 맞게 하는 것이 좋다.

- 준비를 위한 리팩터링: 새 기능 추가하기 전의 리팩터링
- 이해를 위한 리팩터링: 코드 파악을 위한 리팩터링
- 쓰레기 줍기 리팩터링: 작업과는 관련없지만 불필요한 코드 삭제를 위한 리팩터링

그외의 리팩터링의 경우 오래 걸리는 리팩터링과 코드리뷰에서의 리팩터링이 있다. 오래 걸리는 리팩터링과 같은 경우에는 저자는 점진적으로 하나하나씩 수정하는 것이 좋지, 한번에 많은 리팩터링을 하는 것은 좋지 않다고 비판한다. 또한 코드 리뷰과정에서의 리팩터링은 리뷰어와 코드 작성자가 소통하고 계속 좋은 코드로 바꾼다는 점에서 짝 프로그래밍과 유사한 이득을 얻을 수 있다고 한다.

- 오래 걸리는 리팩터링: 몇주가 걸리는 대규모 리팩터링
- 코드 리뷰에서의 리팩터링: 짝 프로그래밍과 동일한 효과를 얻을 수 있는 리팩터링

## 리팩터링을 하지 말아야할 때

저자는 아래와 같은 원칙으로 리팩터링을 하지 않는다.

- 지저분한 코드를 발견하여도 수정할 필요가 없다면 리팩터링 하지 않는다.
- 외부 API 다루듯 호출하는 코드는 리팩터링하지 않는다.
- 리팩터링보다 다시 작성하는 것이 쉬울때에도 리팩터링 하지 않는다.

## 리팩터링에서 고민해봐야할 문제

### 새 기능 개발 속도 저하

리팩터링의 중요 목적은 개발 속도를 높이기 위한 구조로 개선함에 있다. 코드베이스가 건강할 때 기존 코드를 새로운 방식으로 조합하는 것이 더 쉬워진다. 하지만 리팩터링을 위한 리팩터링을 해서는 안된다. 리팩터링의 주요 목적은 경제적인 이유에 있는 것이지 미학적 이유에 있지 않다.

### 코드 소유권

코드 소유권이 나누어져 있는 경우 공개된 public API의 함수 선언 바꾸기와 같은 리팩터링을 수행하기 어려워진다. 그래서 저자는 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 것보다는 팀은 팀이 소유한 모든 코드에 대한 수정권을 갖도록 하는 것이 현명하다고 말한다.

### 브랜치

흔히 기능별로 브랜치를 생성한 후 기능이 모두 개발되었을 때 머지하는 경우가 있다. 이러한 경우에는 머지할때 수많은 충돌이 생길 수 있어 개발 생산성을 저하하는 요인이 된다. 차라리 지속적 통합(CI) 시스템을 구축하여 수시로 머지하는 것이 현명하다.

하지만 이때에는 아직 완성되지 않은 기능이 머지되므로 해당 기능을 제어할 수 있는 feature flag를 두어 시스템 전체가 깨지지 않도록 노력을 기울여야 한다.

### 테스팅

리팩터링에서의 가장 큰 장점은 변경할 부분을 호출하거나 사용하는 caller에서는 동작이 변하지 않는다는 점이다. 하지만 리팩터링 과정에서 실수로 인해 동작 자체가 변화될 수 있으며, 버그가 발생할 우려가 있다. 이 점을 보완하기 위해 변경할 코드를 포함한 단위 테스트를 통해 구현의 반경이 없다는 것을 확신하며 진행할 수 있다. 최근에는 IDE에서 제공하는 자동 리팩터링 기능은 이러한 문제를 유발하지 않음을 확신할 수 있지만 테스트 코드를 작성해두는 것이 장기적으로 보았을 때 이득이다.

### 레거시 코드

레거시 시스템을 리팩터링하여 이해하고 파악하는데에 큰 도움이 된다. 하지만 레거시 시스템의 경우 테스트를 작성하기 어려울 수 있다. 이를 위해 테스트를 추가할 틈새를 찾아서 시스템을 테스트하고, 순차적인 리팩터링 과정으로 점진적으로 개선해나가야 한다.

### 데이터베이스

데이터베이스도 리팩터링을 할 수 있는 대상인데 예를들어 필드 이름을 바꾸는 방법은 아래와 같다.

1. 새 필드를 데이터베이스에 추가
2. 새로운 필드를 사용하기 전에 코드를 새 필드에 대응할 수 있도록 수정
3. 기존 필드 값을 새 필드로 마이그레이션
4. 기존 필드와 새 필드를 동시에 사용하도록 릴리즈
5. 기존 필드를 제거

## 리팩터링, 아키텍처, YAGNI

리팩터링이라는 개념이 아키텍처에 미친 영향은 지대적이다. 두 가지 사고방식을 만들어 냈다.

- 워터 폴 기법으로 모든 기능을 염두하여 설계하지 않아도 된다.
- 아키텍처는 지속적으로 진화할 수 있다.

그리고 그 결과로 YAGNI 원칙이 나왔는데, 필요한 기능요건에 맞는 설계만 하라는 원칙이다.

## 리팩터링과 소프트웨어 개발 프로세스

리팩터링이 유명해진 원인으로 XP 소프트웨어 개발 프로세스가 유행했기 때문이다. XP에서 말하는 자가 테스트 코드, 지속적 통합, 리팩터링이라는 방식을 요구한다. 언제나 릴리즈 할 수 있고 점진적으로 발전할 수 있는 코드 베이스를 만들 수 있다.

## 리팩터링과 성능

리팩터링의 예제를 1장에서 봤듯이 함수 호출이 빈번해지는 문제가 보인다. 성능에 악영향을 미치는 것이 아닌지 의심스러울 수 있지만, 오히려 성능에 필요한 부분을 찾아 수정하는 것이 용이해진다.

저자는 이하의 원칙을 경험을 통해 얻을 수 있었다.

- 시간에 굉장히 크리티컬한 도메인의 프로그램의 경우, 시간 분배 시스템 설계로 컴포넌트마다의 자원을 할당하여 최적화할 수 있다.
- 성능 개선을 위한 최적화 코드가 별 이득이 되지 않을 수 있다.
- 대부분의 코드는 성능과 아무런 영향이 없으므로 90%의 최적화를 위한 시간은 낭비이다.

섣부른 최적화를 하기보다는 프로파일러를 이용하여 성능 저하 부분을 정확하게 파악하고 해당 부분을 해결하는 것이 중요하다. 이때 리팩터링을 한 상태라면 기능 수정과 추가가 용이한 상황이므로 최적화 코드를 추가하는 것도 매우 쉬워진다.

## 리팩터링 유래 [생략]

## 리팩터링 자동화

IDE의 기능이 풍부해지면서 단순한 문자열 모두 바꾸기와 같은 기능이 아닌 리팩터링 전문 기능이 추가되는 경우가 있다. 해당 기능을 이용하여 리팩터링하는 경우 테스트의 필요성이 적어지지만, IDE에 따라 완벽하지 않은 기능을 제공하는 경우도 있으므로 여전히 테스트는 도움이 된다.