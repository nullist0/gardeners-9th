# 코드에서 나는 악취

## 기이한 이름

- 원인: 불명확한 변수/함수/클래스 이름
- 해결책
  - 함수 선언 바꾸기
  - 변수 이름 바꾸기
  - 필드 이름 바꾸기

## 중복 코드

- 원인: 중복되는 코드
- 해결책
  - 동일 클래스내의 코드 중복 : 함수 추출하기
  - 코드가 완전히 같지 않다면 : 문장 슬라이드
  - 서브 클래스간의 코드 중복 : 메서드 올리기

## 긴 함수

- 원인: 사람이 이해하기 어려울 정도로 긴 함수
- 해결책
  - 함수 추출하기
  - 함수의 임시변수 제거: 임시 변수를 질의 함수로 바꾸기
  - 매개변수 줄이기: 매개 변수 객체 만들기 & 객체 통째로 넘기기
  - 임시변수와 매개변수가 너무 많은 경우: 함수를 명령으로 바꾸기
- 추출 대상 탐색 대상 및 해결책
  - switch 문 => 함수 추출하기 & 조건부 로직을 다형성으로 바꾸기
  - 조건 문 => 조건문 분해하기
  - 두가지 작업이 동시에 있는 반복문 => 반복문 쪼개기

## 긴 매개변수 목록

- 원인: 사람이 이해하기 어려울 정도로 많은 매개변수
- 해결책
  - 다른 매개변수로부터 추출할 수 있는 매개변수: 매개변수를 질의 함수로 바꾸기
  - 사용중인 데이터 구조에서 값을 뽑아 별개의 매개변수로 넘기는 경우: 객체 통째로 넘기기
  - 항상 함께 전달되는 매개변수: 매개변수 객체 만들기
  - 함수를 제어하는 플래그 매개변수: 플래그 인수 제거하기
  - 여러 함수가 공통으로 사용하는 매개변수: 여러 함수를 클래스로 묶기

## 전역 데이터

- 원인: 버그 분석이 어려운 전역 데이터 / 클래스 변수 / 싱글톤 객체
- 해결책
  - 값을 수정하는 함수가 여러 곳에 있는 경우: 변수 캡슐화 하기

## 가변 데이터

- 원인: 데이터의 변경 사항을 다른 객체에서 알기 어려움
- 해결책
  - 값을 수정하는 함수가 여러 곳에 있는 경우: 변수 캡슐화 하기
  - 서로다른 용도의 값들을 저장하고 수정하는 경우: 변수 쪼개기, 문장 슬라이드하기, 함수 추출하기
  - API를 만드는 경우: 질의 함수와 변경 함수 분리하기
  - 불변 값으로 바꿀 수 있는 경우: 세터 제거하기, 참조를 값으로 바꾸기
  - 가변 데이터를 제거할 수 있는 경우: 파생 변수를 질의 함수로 바꾸기
  - 유효범위가 넓어서 추적하기 어려운 경우: 여러 홤수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기


## 뒤엉킨 변경

- 원인: 단일 책임 원칙을 위배하여 한 모듈이 둘 이상의 책임을 가짐
- 해결책
  - 서로다른 처리 로직이 순차적인 경우: 단계 쪼개기
  - 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높은 경우: 함수 옮기기, 함수 추출하기, 클래스 추출하기

## 산탄총 수술

- 원인: 한 기능을 수정하기 위해 수정해야할 코드가 다양한 모듈에 분포하는 경우
- 해결책
  - 함께 변경되는 대상이 있는 경우: 함수 옮기기, 필드 옮기기
  - 비슷한 데이터를 다루는 함수가 많은 경우: 여러 함수를 클래스로 묶기
  - 데이터 구조를 변환하거나 보강하는 함수의 경우: 여러 함수를 변환함수로 묶기
  - 묶인 함수들의 출력결과를 묶어서 다음 단계의 로직으로 전달할 수 있는 경우: 단계 쪼개기
  - 어설프게 분리된 로직이 있는 경우: 함수 인라인 하기, 클래스 인라인하기

## 기능 편애

- 원인: 다른 모듈에 대한 함수 호출이 더 많은 함수가 존재하여 다른 모듈의 수정에 영향을 받음
- 해결책
  - 전체를 옮길 수 있는 경우: 함수 옮기기
  - 부분적으로만 옮길 수 있는 경우: 함수 추출하기, 함수 옮기기
  - 옮겨야할 대상 모듈이 명확치 않은 경우: 함수 추출하기

## 데이터 뭉치

- 원인: 동시에 같이 사용되는 데이터가 따로 구분되어 있음
- 해결책
  - 데이터 뭉치가 필드에 있는 경우: 클래스 추출하기
  - 데이터 뭉치가 메서드 시그니처에 있는 경우: 매개변수 객체 만들기 혹은 객체 통째로 넘기기
- 데이터 뭉치 식별 방법
  - 값 하나를 제거하여 다른 값이 제구실을 못하면 데이터 뭉치로 판단 가능

## 기본형 집착

- 원인: 도메인에 맞는 값을 기본형으로 사용함
- 해결책
  - 기본형을 객체로 바꾸기
  - 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰인 경우: 타입 코드를 서브클래스로 바꾸기 & 조건부 로직을 다형성으로 바꾸기
  - 같이 몰려다니는 기본형 그룹이 있는 경우: 클래스 추출하기 & 매개변수 객체 만들기

## 반복되는 switch 문

- 원인: 조건절을 추가할 때마다 다른 switch 문을 모두 찾아서 수정해야 함
- 해결책
  - 조건부 로직을 다형성으로 바꾸기

## 반복문

- 원인: 도메인 객체가 실제로 반복가능함을 누출함
- 해결책
  - 반복문을 파이프라인으로 바꾸기

## 성의 없는 요소

- 원인: 중복적으로 사용되지 않는 불필요한 프로그래밍 요소의 존재로 인지적 부하 상승
- 해결책
  - 클래스내에 있는 경우: 함수 인라인하기 / 클래스 인라인하기
  - 상속을 사용한 경우: 계층 합치기

## 추측성 일반화

- 원인: 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드 존재로 관리 하기 어려움
- 해결책
  - 하는 일이 없는 추상 클래스의 경우: 계층 합치기
  - 쓸데없이 위임하는 코드의 경우: 함수 인라인 하기 / 클래스 인라인 하기
  - 본문에서 사용되지 않는 매개변수의 경우: 함수 선언 바꾸기
  - 사용되지 않는 코드의 경우: 죽은 코드 제거하기

## 임시 필드

- 원인: 특정상황에만 값이 설정되는 필드를 가진 클래스의 존재로 인한 코드 가독성 저하
- 해결책
  - 일반적인 경우: 클래스 추출하기, 함수 옮기기
  - 임시 필드를 확인해야하는 조건부 로직의 경우: 특이 케이스 추가하기

## 메시지 체인

- 원인: 클라이언트가 한 객체를 통해 연쇄적으로 함수 호출을 하여 객체 내비게이션 구조에 종속되는 경우
- 해결책
  - 일반적인 경우: 위임 숨기기
  - 결과 객체를 아예 숨길 수 있는 경우: 함수 추출하기 & 함수 옮기기

## 중개자

- 원인: 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하는 경우
- 해결책
  - 일반적인 경우: 중개자 제거하기
  - 위임 메서드가 대부분인 경우: 함수 인라인 하기

## 내부자 거래

- 원인: 모듈 사이의 데이터 거래가 많아 결합도가 높고 추적하기 어려움
- 해결책
  - 데이터를 은밀하게 주고받는 경우: 함수 옮기기 & 필드 옮기기
  - 여러 모듈이 같은 관심가를 공유하는 경우: 새 모듈 작성 / 위임 숨기기
  - 상속 구조를 분리해야하는 경우: 서브클래스를 위임으로 바꾸기 / 슈퍼 클래스를 위임으로 바꾸기

## 거대한 클래스

- 원인: 한 클래스에 너무 많은 필드들이 정의되어 있거나 코드량이 너무 많아 관리하기 어려워짐
- 해결책
  - 일반적인 경우: 클래스 추출하기
  - 분리할 컴포넌트가 상속관계로 두는 것이 좋은 경우: 슈퍼 클래스 추출하기 / 타입 코드를 서브클래스로 바꾸기
  - 코드량이 너무 많은 경우: 함수 추출하기, 클래스 추출하기, 슈퍼 클래스 추출하기, 타입 코드를 서브클래스로 바꾸기


## 서로 다른 인터페이스의 대안 클래스들

- 원인: 클래스를 통해서 객체를 교체할 때 인터페이스가 다른 경우
- 해결책
  - 인터페이스가 다른경우: 함수 선언 바꾸기
  - 추가로 다른 함수가 필요한 경우: 함수 옮기기
  - 중복 코드가 발생하는 경우: 슈퍼 클래스 추출하기

## 데이터 클래스

> 데이터 클래스: 데이터 필드와 게터/세터 메서드로만 구성된 클래스

- 원인: 다른 클래스가 데이터 클래스를 위법적으로 사용하는 것이 생기는 경우
- 해결책
  - public 필드가 있는 경우: 레코드 캡슐화하기
  - 변경되지 말아야할 필드의 경우: 세터 숨기기
  - 다른 클래스에서 게터나 세터를 사용하여 로직을 구현하며 다른 로직이 없는 경우: 함수 옮기기
  - 메서드를 통째로 옮기기 어려운 경우: 함수 추출하기
- 주의점
  - 불변 데이터의 경우 게터가 불필요한 경우도 있다. public으로 노출해도 된다면 노출해라.

## 상속 포기

- 원인: 부모의 동작은 필요하지만 인터페이스까지 따를 필요가 없는 경우
- 해결책
  - 일반적인 경우: 서브클래스를 위임으로 바꾸기 / 슈퍼 클래스를 위임으로 바꾸기

## 주석

> 주석이 필요없다는 말은 아니다. 하지만 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요없는 코드로 리팩터링해본다.

- 원인: 주석이 코드를 잘못 작성하여서 생긴 경우
- 해결책
  - 특정 코드 블록이 하는 일에 주석을 남기고 싶은 경우: 함수 추출하기
  - 추출된 함수에서 설명이 필요한 경우: 함수 선언 바꾸기
  - 시스템이 동작하기 위한 선행 조건을 명시하고 싶은 경우: 어서션 추가하기

