# 효과적인 모델링의 요소

---

책에서 PCB에서의 예제에서 다음과 같은 성공을 이끌어내는 요소를 엿볼 수 있다.

1. 모델과 구현의 연계
2. 모델을 기반으로 하는 언어 정제
3. 풍부한 지식이 담긴 모델 개발
4. 모델의 정제
5. 브레인스토밍과 실험

# 지식 탐구

---

소프트웨어 개발자들은 도메인 모델에 대해서 탐구하고 개발해야하는데, 이 과정에서 앞서 살펴본 것과 같이 **지식 탐구**가 필수적이다. 그러기 위해서는 개발 프로세스부터가 이에 적합해야 한다. 여러 프로세스를 알아보자.

## 폭포수 개발 방식

도메인 탐구의 방식에서는 실패한다.

- 지식의 전달 순서: 업무 전문가 ⇒ 분석가 ⇒ 프로그래머
- 모델 탐구의 책임: 분석가

업무 전문가와 프로그래머 간의 소통이 부재하여 지식이 그저 흘러갈뿐 축적되지 않는다.

## 반복 프로세스 & 추상화 부재

- 지식의 전달 순서: 업무 전문가 ⇒ 개발자
- 모델 탐구의 책임: 개발자이지만 추상화를 하지 않음

업무 전문가가 기술한 문제를 개발자가 단순히 해결하지만 이면에 있는 도메인의 문제를 탐구하지 않아 발전되지 않는다.

## 반복 프로세스 & 추상화

- 지식의 전달 순서: 업무 전문가 ⇒ 개발자, 개발자 ⇒ 업무 전문가
- 모델 탐구의 책임: 업무 전문가, 개발자

개발자가 적극적으로 도메인의 지식을 추상화하고 업무 전문가와 토의한다면 도메인 지식 탐구에 있어 성공할 수 있다! 이런 과정을 통해서,

- 업무 전문가는 프로그램에서 필요한 개념적 엄밀함을 이해할 수 있고
- 개발자는 업무 전문가가 원하는 문제를 충분히 추상화하고 해결할 수 있다.

## 지식 탐구의 결과

모든 팀원들의 도메인 지식의 상승은 결과적으로 더 나은 도메인의 이해와 더불어 더 가치있는 도메인 모델을 설계할 수 있게된다. 하지만 염두해야 할 것은,

> 모델은 결코 완벽해질 수 없으며, 다만 계속 발전해나갈 뿐이다. 모델은 도메인을 이해하는 데 실용적이고 유용해야 한다. 또한 모델은 쉽게 구현하고 이해하기에 충분할 정도로 엄밀해야 한다.


위의 문제를 해결하려면 **도메인이 가진 실체를 구현해야하는데 이는 불가능**하다.

# 지속적인 학습 - Continous learning

---

어떠한 도메인에 대한 학습을 멈추지 않고 계속 지속해야 하는 것은 **너무나도 당연한 말**처럼 보인다. 그렇지만 다시 한번 그 중요성에 대해 상기해보자.

- 소프트웨어를 작성하기 전에 우리는 충분히 도메인에 대해 알지 못한 상태에서 개발한다.
    - 무엇이 중요한지도 모른다.
    - 지식은 단편적이다.
    - 무지는 잘못된 가정을 만든다.
- 모든 지식은 팀원의 변경과 같은 외부 요인으로 인해 변화한다.
- 생산성이 매우 뛰어난 팀은 지속적인 학습을 통해서 의식적으로 지식을 함양한다 - Kerievsky 2003

> 스스로 학습하는 팀원은 가장 핵심적인 부분을 개발하는 데 초점을 맞춘 고정 핵심 인력을 형성한다. 이러한 핵심 팀원에게 축적된 지식으로 그들은 더욱 유능한 지식 탐구자가 된다.
> 

# 풍부한 지식이 담긴 설계

---

지식탐구와 지속적인 학습을 통해서 얻은 지식으로 설계를 한다는 것은 결국 어떤 설계를 할 수 있다는 것일까? 우리는 지식 탐구와 지속적인 학습을 통해서 아래와 같은 것들을 학습할 수 있다.

- 도메인과 관련된 엔티티
- 도메인이 요구하는 업무 활동
- 도메인이 요구하는 규칙
- 도메인이 갖는 개념들의 범주 규칙

# 예시: 금융업 도메인

---

매우 간단한 금융업 관련 도메인을 구현한다고 생각하자. 

## 요구사항: `Cost`(비용)은 `Payment`(결제)을 통해 정산된다.

이러한 요구사항은 아래와 같이 간단하게 구현될 수 있다.

```kotlin
fun purchase(cost: Cost, payment: Payment): Int {
    val confirmation: Int = paymentConfigurationSequence.next()
    payment.addCost(cost, confirmation)
    return confirmation
}
```

## 요구사항: 결제는 잔고이하의 금액만 결제 가능하다.

금융업에서 당연하지만, 잔고 초과의 금액을 결제할 수 없다. 이를 서술해보면 아래와 같다.

- 행위: 비용을 결제를 통해 정산한다.
    1. 결제가 가능한지 잔고 초과 규칙을 통해 검사한다.
    2. 확인한 결과 불가능하다면 정산에 실패한다.
    3. 확인한 결과 가능하다면 정산을 진행한다.

우리는 간단하게 아래와 같이 구현하는 것이 가능하다.

```kotlin
fun purchase(cost: Cost, payment: Payment): Int {
    // guard clause: 잔고 규칙 대한 처리를 한다.
    val maxCost = payment.maximumCost()
    if ((cost.value() + payment.currentCost()) > maxCost) {
        return -1
    }

    // 정산을 진행한다.
    val confirmation = paymentConfigurationSequence.next()
    payment.addCost(cost, confirmation)
    return confirmation
}
```

개발자의 입장에서 코드는 매우 단순하고 이해하기 어렵지 않지만 문제가 존재한다.

- 코드가 작성된 대로라면 개발자의 도움이 있더라도 **업무 전문가가 이 코드를 읽고 규칙을 검증하지 못한다**.
- 해당 업무에 종사하지 않고 **기술적인 측면만 담당하는 사람은 코드와 요구사항을 결부시키기 어렵다**.

<aside>
💡 여기서는 한줄로 표현되는 계산이라 쉬워보이지만 100줄 이상의 계산이 필요한 조건을 작성한다고 가정해보면 개발자도 코드를 이해하기 어렵다.
</aside>

점차 내용이 진행되면서 중요한 문제를 밝히게 될 것이지만, 여기서는 **정책**이라는 개념의 부재가 매우 크다. 정책에 관한 개념을 추가하여 다시 코드를 작성하게 되면….

```kotlin
fun purchase(cost: Cost, payment: Payment): Int {
    // guard clause: 잔고 규칙에 대한 구현이 도메인 언어와 동일해진다.
    if (!maxCostPolicy.isAllowed(cost, payment)) {
        return -1
    }

    // 정산을 진행한다.
    val confirmation = paymentConfigurationSequence.next()
    payment.addCost(cost, confirmation)
    return confirmation
}

class MaxCostPolicy {
    // 업무 전문가가 이해하기 어려운 구현은 해당 클래스로 감춰진다.
    fun isAllowed(cost: Cost, payment: Payment): Boolean =
        (cost.value() + payment.currentCost()) > payment.maximumCost()
}
```

이러한 설계를 모든 곳에서 적용하라는 의미로 예제를 설명하는 것이 아니지만, 명시적 설계에 관해 설명할 수 있다.

- 설계 수준을 올리고자 한다면 개발자가 어떠한 계산이 단순한 계산이 아닌 중요한 업무 규칙임을 알아야 한다.
- 프로그래머는 업무 전문가에게 그들이 이해할 수 있는 수준에서 기술적 산출물, 심지어 코드까지도 보여줄 수 있으며 피드백을 받을 수 있어야 한다.

# 요약: 심층 모델로 가는 길…

---

> 유용한 모델이 겉으로 드러나 있는 경우는 거의 없다. 우리는 도메인과 애플리케이션의 요구사항을 이해하게 되면서 대체로 처음에 중요하게 생각했던 피상적인 모델 요소를 버리거나 관점을 바꾼다. 이로써 처음에는 나타나기 힘들지만 문제의 핵심을 관통하는 포착하기 힘든 추상화가 서서히 나타나기 시작한다.

지식 탐구가 도메인 주도 설계의 시작이다.